# code for Fruit Loop Game - Daniel Zelinger



# fruit_loop_game_V19_ANTI_CRASH_BUZZER_SAFE_PIXELS.py

import time
import random
import board
import busio
import displayio
import terminalio
import digitalio
import neopixel
import pwmio
import gc  # <--- CRITICAL IMPORT FOR MEMORY MANAGEMENT

from adafruit_display_text import label
from i2cdisplaybus import I2CDisplayBus
import adafruit_displayio_ssd1306
import adafruit_adxl34x

from rotary_encoder import RotaryEncoder

# -----------------------------
# ðŸ› ï¸ Hardware Setup
# -----------------------------

displayio.release_displays()

# I2C for OLED + (optional) ADXL345
i2c = board.I2C()  # uses board.SCL and board.SDA

# (Optional) quick scan
while not i2c.try_lock():
    pass
print("I2C addresses found:", [hex(addr) for addr in i2c.scan()])
i2c.unlock()

# OLED display (SSD1306 128x64) at 0x3C
display_bus = I2CDisplayBus(i2c, device_address=0x3C)
display = adafruit_displayio_ssd1306.SSD1306(display_bus, width=128, height=64)

# Accelerometer (ADXL345 at 0x53) â€“ optional
try:
    accelerometer = adafruit_adxl34x.ADXL345(i2c)
    print("ADXL345 found at 0x53")
except Exception:
    accelerometer = None
    print("Warning: ADXL345 not found; shake-to-restart disabled")

# Rotary Encoder pins (change if your wiring is different)
ENCODER_DT = board.D8
ENCODER_CLK = board.D9
ENCODER_SW = board.D10

encoder = RotaryEncoder(ENCODER_DT, ENCODER_CLK,
                        debounce_ms=3, pulses_per_detent=3)

# Encoder button
button = digitalio.DigitalInOut(ENCODER_SW)
button.direction = digitalio.Direction.INPUT
button.pull = digitalio.Pull.UP
last_button_state = button.value

# NeoPixel on D7 (or built-in NEOPIXEL if present)
try:
    NEO_PIN = board.NEOPIXEL
except AttributeError:
    NEO_PIN = board.D7

NUM_PIXELS = 1
_pixels_ok = True  # flag to disable pixels if they ever OOM

pixels = neopixel.NeoPixel(
    NEO_PIN,
    NUM_PIXELS,
    brightness=0.3,
    auto_write=True
)


def safe_set_pixel(color):
    """
    Safely set the NeoPixel color.
    If the underlying ESP-IDF runs out of memory once,
    we stop trying to update pixels to avoid further crashes.
    """
    global _pixels_ok
    if not _pixels_ok:
        return
    try:
        pixels[0] = color
    except Exception as e:
        # espidf.MemoryError or other low-level issues
        print("NeoPixel error, disabling pixels:", repr(e))
        _pixels_ok = False


# -----------------------------
# ðŸ”” Buzzer Setup
# -----------------------------

# CHANGE THIS to the pin where your piezo is connected:
BUZZER_PIN = board.D0  

buzzer = pwmio.PWMOut(BUZZER_PIN, duty_cycle=0,
                      frequency=440, variable_frequency=True)


def _beep(freq=1000, duration=0.1, duty=2**14):
    """Single beep helper."""
    buzzer.frequency = freq
    buzzer.duty_cycle = duty
    time.sleep(duration)
    buzzer.duty_cycle = 0


def sound_power_on():
    _beep(880, 0.08)
    _beep(1320, 0.08)


def sound_game_start():
    _beep(660, 0.07)
    _beep(880, 0.07)


def sound_eat():
    _beep(1300, 0.04)


def sound_game_over():
    _beep(440, 0.20)
    _beep(330, 0.25)


def sound_win():
    for f in (880, 1046, 1318, 1760):
        _beep(f, 0.08)


COLOR_OFF        = (0, 0, 0)
COLOR_MENU       = (0, 0, 255)      # blue
COLOR_PLAY       = (0, 255, 0)      # green
COLOR_GAME_OVER  = (255, 0, 0)      # red
COLOR_WIN        = (255, 165, 0)    # orange-ish

# -----------------------------
# ðŸŽ Game Constants
# -----------------------------

SCREEN_W = 128
SCREEN_H = 64
TILE_SIZE = 8
GRID_W = 21
GRID_H = 9

DIFFICULTIES = [
    ("SLOW",     0.35),
    ("STANDARD", 0.20),
    ("FAST",     0.10),
]

STATE_SPLASH    = 0
STATE_MENU      = 1
STATE_PLAYING   = 2
STATE_GAME_OVER = 3
STATE_WIN       = 4

# -----------------------------
# ðŸ’¾ High Score Helpers
# -----------------------------


def load_high_score():
    try:
        with open("highscore.txt", "r") as f:
            txt = f.read().strip()
            return float(txt)
    except Exception:
        return None


def save_high_score(best_time):
    try:
        with open("highscore.txt", "w") as f:
            f.write("{:.2f}".format(best_time))
    except Exception:
        pass

# -----------------------------
# ðŸ“³ Shake Detector
# -----------------------------


class ShakeDetector:
    def __init__(self, threshold=5.0, window_seconds=1.5):
        self.threshold = threshold
        self.window_seconds = window_seconds
        self.shakes = 0
        self.last_shake_time = 0.0

        self.enabled = accelerometer is not None
        if not self.enabled:
            self.last_mag = 0.0
            return

        x, y, z = accelerometer.acceleration
        self.last_mag = (x*x + y*y + z*z) ** 0.5

    def update(self):
        if not self.enabled:
            return False

        x, y, z = accelerometer.acceleration
        mag = (x*x + y*y + z*z) ** 0.5
        diff = abs(mag - self.last_mag)
        self.last_mag = mag

        now = time.monotonic()
        if now - self.last_shake_time > self.window_seconds:
            self.shakes = 0

        if diff > self.threshold:
            self.shakes += 1
            self.last_shake_time = now
            # small blink, but safe:
            safe_set_pixel((100, 100, 0))
            time.sleep(0.05)
            safe_set_pixel((0, 0, 0))

        if self.shakes >= 3:
            self.shakes = 0
            return True
        return False


shake_detector = ShakeDetector()

# -----------------------------
# ðŸ Game Class
# -----------------------------


class FruitLoopGame:
    def __init__(self, display):
        self.display = display
        self.splash_group = displayio.Group()
        self.menu_group = displayio.Group()
        self.play_group = displayio.Group()
        self.gameover_group = displayio.Group()
        self.win_group = displayio.Group()

        self.state = STATE_SPLASH
        self.current_group = self.splash_group
        self.display.root_group = self.current_group

        self.splash_start = time.monotonic()
        self.splash_last_text_time = time.monotonic()
        self.splash_text_state = 0
        self.game_start_time = None
        self.game_end_time = None

        self.difficulty_index = 1
        self.base_interval = DIFFICULTIES[self.difficulty_index][1]
        self.step_interval = self.base_interval
        self.last_step_time = time.monotonic()

        self.snake = []
        self.direction = (1, 0)
        self.apple = None
        self.level = 1
        self.apples_eaten = 0

        # track score updates
        self.last_score_update_time = 0

        self.board_labels = []
        self.last_encoder_pos = encoder.position

        self.best_time = load_high_score()

        # Build UI
        self._build_splash()
        self._build_menu()
        self._build_play()
        self._build_gameover()
        self._build_win()

        # Initial GC
        gc.collect()

    # ---------- UI Builders ----------

    def _build_splash(self):
        self.splash_title_label = label.Label(
            terminalio.FONT,
            text="FRUIT",
            x=25,
            y=30,
            scale=3,
        )
        self.splash_group.append(self.splash_title_label)

        self.splash_hint_label = label.Label(
            terminalio.FONT,
            text="",
            x=5,
            y=55,
        )
        self.splash_group.append(self.splash_hint_label)

    def _build_menu(self):
        self.menu_title = label.Label(
            terminalio.FONT,
            text="FRUIT LOOP",
            x=0,
            y=4,
            scale=1,
        )
        self.menu_group.append(self.menu_title)

        self.menu_diff_label = label.Label(
            terminalio.FONT,
            text="Difficulty:",
            x=5,
            y=25,
        )
        self.menu_group.append(self.menu_diff_label)

        self.menu_diff_value = label.Label(
            terminalio.FONT,
            text=DIFFICULTIES[self.difficulty_index][0],
            x=5,
            y=40,
            scale=1,
        )
        self.menu_group.append(self.menu_diff_value)

        self.menu_hint_text = " ROTATE to choose | BUTTON to select " * 2
        self.menu_hint = label.Label(
            terminalio.FONT,
            text=self.menu_hint_text,
            x=128,
            y=57,
        )
        self.menu_group.append(self.menu_hint)
        self.menu_scroll_x = 128
        self.menu_scroll_speed = 2
        self.menu_max_scroll = len(self.menu_hint_text) * 6.5

    def _build_play(self):
        self.play_info_label = label.Label(
            terminalio.FONT,
            text="Lvl 1 Time 0.0",
            x=0,
            y=4,
        )
        self.play_group.append(self.play_info_label)

        self.board_labels = []
        start_y = 10
        row_step = 6
        for i in range(GRID_H):
            row_label = label.Label(
                terminalio.FONT,
                text=" " * GRID_W,
                x=0,
                y=start_y + i * row_step,
            )
            self.board_labels.append(row_label)
            self.play_group.append(row_label)

    def _build_gameover(self):
        self.go_label = label.Label(
            terminalio.FONT,
            text="GAME OVER :(",
            x=15,
            y=25,
            scale=2,
        )
        self.gameover_group.append(self.go_label)

        self.go_time_label = label.Label(
            terminalio.FONT,
            text="Time: 0.0s",
            x=15,
            y=40,
        )
        self.gameover_group.append(self.go_time_label)

        self.go_hint_text = " BUTTON to Menu | SHAKE to Retry " * 2
        self.go_hint = label.Label(
            terminalio.FONT,
            text=self.go_hint_text,
            x=128,
            y=58,
        )
        self.gameover_group.append(self.go_hint)
        self.go_scroll_x = 128
        self.go_scroll_speed = 2
        self.go_max_scroll = len(self.go_hint_text) * 6.5

    def _build_win(self):
        self.win_label = label.Label(
            terminalio.FONT,
            text="YOU WIN!",
            x=30,
            y=20,
            scale=2,
        )
        self.win_group.append(self.win_label)

        self.win_time_label = label.Label(
            terminalio.FONT,
            text="Time: 0.0s",
            x=15,
            y=35,
        )
        self.win_group.append(self.win_time_label)

        self.win_best_label = label.Label(
            terminalio.FONT,
            text="Best: --",
            x=15,
            y=47,
        )
        self.win_group.append(self.win_best_label)

        self.win_hint_text = " BUTTON to Menu | SHAKE to Retry " * 2
        self.win_hint = label.Label(
            terminalio.FONT,
            text=self.win_hint_text,
            x=128,
            y=58,
        )
        self.win_group.append(self.win_hint)
        self.win_scroll_x = 128
        self.win_scroll_speed = 2
        self.win_max_scroll = len(self.win_hint_text) * 6.5

    # ---------- State Helpers ----------

    def set_state(self, new_state):
        # MEMORY FIX: Clean up before switching state/graphics
        gc.collect()

        self.state = new_state
        if new_state == STATE_SPLASH:
            self.current_group = self.splash_group
            safe_set_pixel(COLOR_MENU)
            self.splash_text_state = 0
            self.splash_start = time.monotonic()
            self.splash_title_label.text = "FRUIT"
        elif new_state == STATE_MENU:
            self.current_group = self.menu_group
            safe_set_pixel(COLOR_MENU)
        elif new_state == STATE_PLAYING:
            self.current_group = self.play_group
            safe_set_pixel(COLOR_PLAY)
        elif new_state == STATE_GAME_OVER:
            self.current_group = self.gameover_group
            safe_set_pixel(COLOR_GAME_OVER)
        elif new_state == STATE_WIN:
            self.current_group = self.win_group
            safe_set_pixel(COLOR_WIN)

        self.display.root_group = self.current_group

        # MEMORY FIX: Clean up after group switch
        gc.collect()

    # ---------- Game Logic ----------

    def start_new_game(self):
        start_x = GRID_W // 2
        start_y = GRID_H // 2
        head = (start_x, start_y)
        body = (start_x - 1, start_y)
        self.snake = [head, body]

        self.direction = (1, 0)
        self.level = 1
        self.apples_eaten = 0

        self.base_interval = DIFFICULTIES[self.difficulty_index][1]
        self.step_interval = self.base_interval

        self._place_apple()

        self.game_start_time = time.monotonic()
        self.game_end_time = None
        self.last_step_time = time.monotonic()
        self.last_score_update_time = time.monotonic()

    def _place_apple(self):
        # Pick and Check Method (RAM Safe)
        for _ in range(50):
            x = random.randrange(1, GRID_W - 1)
            y = random.randrange(1, GRID_H - 1)
            if (x, y) not in self.snake:
                self.apple = (x, y)
                return
        self.trigger_win()

    def update_play(self, now):
        if now - self.last_step_time >= self.step_interval:
            self.last_step_time = now
            self._step_snake()

        # MEMORY FIX: Update Text ONLY once per second OR if score changed
        if self.game_start_time is not None:
            if ((now - self.last_score_update_time > 1.0) or
               (self.apples_eaten * 10 != self.parse_score(self.play_info_label.text))):
                elapsed = now - self.game_start_time
                self.play_info_label.text = "LVL:{} T:{:.0f} S:{}".format(
                    self.level, elapsed, self.apples_eaten * 10
                )
                self.last_score_update_time = now
                gc.collect()

        self._draw_board()

    def parse_score(self, text):
        try:
            return int(text.split("S:")[1])
        except Exception:
            return -1

    def _step_snake(self):
        if self.state != STATE_PLAYING:
            return

        head_x, head_y = self.snake[0]
        dx, dy = self.direction
        new_x = head_x + dx
        new_y = head_y + dy

        # Wraparound Logic
        if new_x <= 0:
            new_x = GRID_W - 2
        elif new_x >= GRID_W - 1:
            new_x = 1
        if new_y <= 0:
            new_y = GRID_H - 2
        elif new_y >= GRID_H - 1:
            new_y = 1

        if (new_x, new_y) in self.snake:
            self.trigger_game_over()
            return

        new_head = (new_x, new_y)
        self.snake.insert(0, new_head)

        if self.apple is not None and (new_x, new_y) == self.apple:
            # ate apple
            sound_eat()

            self.apples_eaten += 1
            self.level = max(self.apples_eaten, 1)
            self.step_interval = max(
                0.05, self.base_interval * (0.95 ** self.level)
            )
            self._place_apple()

            if self.game_start_time:
                elapsed = time.monotonic() - self.game_start_time
                self.play_info_label.text = "LVL:{} T:{:.0f} S:{}".format(
                    self.level, elapsed, self.apples_eaten * 10
                )

            if self.apples_eaten >= 10:
                self.trigger_win()
                return
        else:
            self.snake.pop()

    def _draw_board(self):
        grid = [[" " for _ in range(GRID_W)] for _ in range(GRID_H)]

        for x in range(GRID_W):
            grid[0][x] = "="
            grid[GRID_H - 1][x] = "="
        for y in range(GRID_H):
            grid[y][0] = "|"
            grid[y][GRID_W - 1] = "|"

        grid[0][0] = "+"
        grid[0][GRID_W - 1] = "+"
        grid[GRID_H - 1][0] = "+"
        grid[GRID_H - 1][GRID_W - 1] = "+"

        if self.apple is not None:
            ax, ay = self.apple
            if 0 < ay < GRID_H and 0 < ax < GRID_W:
                grid[ay][ax] = "@"

        dx, dy = self.direction
        head_char = ">" if dx == 1 else "<" if dx == -1 else "^" if dy == -1 else "v"

        for idx, (x, y) in enumerate(self.snake):
            if 0 < y < GRID_H and 0 < x < GRID_W:
                if idx == 0:
                    grid[y][x] = head_char
                else:
                    grid[y][x] = "#"

        for row in range(GRID_H):
            if row < len(self.board_labels):
                self.board_labels[row].text = "".join(grid[row])

    def trigger_game_over(self):
        self.game_end_time = time.monotonic()
        elapsed = self.game_end_time - self.game_start_time
        self.go_time_label.text = "Time: {:.1f}s".format(elapsed)

        sound_game_over()
        self.set_state(STATE_GAME_OVER)

    def trigger_win(self):
        self.game_end_time = time.monotonic()
        elapsed = self.game_end_time - self.game_start_time
        self.win_time_label.text = "Time: {:.1f}s".format(elapsed)

        if self.best_time is None or elapsed < self.best_time:
            self.best_time = elapsed
            save_high_score(self.best_time)

        if self.best_time is not None:
            self.win_best_label.text = "Best: {:.1f}s".format(self.best_time)
        else:
            self.win_best_label.text = "Best: --"

        sound_win()
        self.set_state(STATE_WIN)

    # ---------- Input Handling ----------

    def update_inputs(self):
        global last_button_state

        encoder.update()
        current_pos = encoder.position
        delta = current_pos - self.last_encoder_pos
        self.last_encoder_pos = current_pos

        current_button = button.value
        button_pressed = (last_button_state is True) and (current_button is False)
        last_button_state = current_button

        return delta, button_pressed

    def handle_menu_input(self, delta, button_pressed):
        if delta != 0:
            direction = 1 if delta > 0 else -1
            self.difficulty_index = (
                self.difficulty_index + direction
            ) % len(DIFFICULTIES)
            name, _ = DIFFICULTIES[self.difficulty_index]
            self.menu_diff_value.text = name

        if button_pressed:
            sound_game_start()
            self.start_new_game()
            self.set_state(STATE_PLAYING)

    def _rotate_direction(self, right_turn=True):
        dx, dy = self.direction
        if right_turn:
            self.direction = (dy, -dx)
        else:
            self.direction = (-dy, dx)

    def handle_play_input(self, delta, button_pressed):
        if button_pressed and self.state == STATE_PLAYING:
            self._rotate_direction(right_turn=True)

    def handle_end_screen_input(self, button_pressed):
        if button_pressed:
            self.set_state(STATE_MENU)

    # ---------- Updates ----------

    def _update_splash_sequence(self, now):
        if self.splash_text_state == 2:
            return
        WORD_DISPLAY_TIME = 0.5
        if now - self.splash_start >= WORD_DISPLAY_TIME:
            self.splash_start = now
            self.splash_text_state += 1
            if self.splash_text_state == 1:
                self.splash_title_label.text = "LOOP"
            elif self.splash_text_state == 2:
                self.set_state(STATE_MENU)
                self.splash_title_label.text = "GO!"

    def _update_menu_scroll(self):
        self.menu_scroll_x -= self.menu_scroll_speed
        if self.menu_scroll_x < -self.menu_max_scroll / 2:
            self.menu_scroll_x = 128
        self.menu_hint.x = self.menu_scroll_x

    def _update_end_scroll(self, scroll_x_attr, hint_label, max_scroll_attr):
        current_x = getattr(self, scroll_x_attr)
        max_scroll = getattr(self, max_scroll_attr)
        current_x -= self.go_scroll_speed
        if current_x < -max_scroll / 2:
            current_x = 128
        setattr(self, scroll_x_attr, current_x)
        hint_label.x = current_x

    def update(self):
        gc.collect()

        now = time.monotonic()

        if self.state == STATE_SPLASH:
            self._update_splash_sequence(now)
            return

        if shake_detector.update():
            if self.state == STATE_PLAYING:
                self.set_state(STATE_MENU)
            elif self.state in (STATE_GAME_OVER, STATE_WIN):
                self.start_new_game()
                self.set_state(STATE_PLAYING)
            return

        delta, button_pressed = self.update_inputs()

        if self.state == STATE_MENU:
            self._update_menu_scroll()
            self.handle_menu_input(delta, button_pressed)

        elif self.state == STATE_PLAYING:
            self.handle_play_input(delta, button_pressed)
            self.update_play(now)

        elif self.state == STATE_GAME_OVER:
            self._update_end_scroll('go_scroll_x', self.go_hint, 'go_max_scroll')
            self.handle_end_screen_input(button_pressed)

        elif self.state == STATE_WIN:
            self._update_end_scroll('win_scroll_x', self.win_hint, 'win_max_scroll')
            self.handle_end_screen_input(button_pressed)


# -----------------------------
# Main Loop
# -----------------------------

sound_power_on()

game = FruitLoopGame(display)

while True:
    game.update()
    time.sleep(0.02)
